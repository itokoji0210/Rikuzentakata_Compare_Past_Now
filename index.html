<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <!-- CSP：YouTube系以外を極力ブロック -->
  <meta http-equiv="Content-Security-Policy"
        content="
          default-src 'self';
          script-src 'self' https://www.youtube.com https://www.youtube-nocookie.com https://s.ytimg.com 'unsafe-inline';
          style-src  'self' 'unsafe-inline';
          img-src    'self' data: blob: https://i.ytimg.com;
          frame-src  https://www.youtube.com https://www.youtube-nocookie.com;
          connect-src 'self' https://www.youtube.com https://*.googlevideo.com;
          media-src  https://*.googlevideo.com;
          font-src   'self' data:;
          object-src 'none';
          base-uri   'self';
          form-action 'self';
        ">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>陸前高田（震災直後と現在）３Ｄ動画 比較</title>
  <meta name="description" content="陸前高田の震災直後と現在の3D動画を同期再生し、スライダー/フェード/単体表示で比較できるデモ。" />
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ccircle cx='50' cy='50' r='46' fill='%235b9cff'/%3E%3Ctext x='50' y='58' text-anchor='middle' font-size='56' fill='white' font-family='Arial, sans-serif'%3ERT%3C/text%3E%3C/svg%3E" />
  <style>
    :root { --bg:#0f1115; --panel:#151822; --muted:#9aa3b2; --fg:#e7ebf3; --accent:#5b9cff; --radius:16px; }
    *{box-sizing:border-box} html,body{height:100%}
    body{margin:0;background:radial-gradient(1200px 800px at 80% -10%,#1b2030 0%,var(--bg) 40%,var(--bg) 100%);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Noto Sans JP,Helvetica,Arial}
    .wrap{max-width:1500px;margin:24px auto;padding:0 16px 48px}
    .header{display:flex;gap:12px;align-items:center;justify-content:space-between;margin-bottom:12px}
    .title{font-size:clamp(18px,2.4vw,28px);font-weight:700}
    .note{color:var(--muted);font-size:12px}

    /* 動画エリア */
    .video-shell{
      position:relative;
      width:min(96vw, 1400px);
      margin:0 auto;
      aspect-ratio:16/9;
      background:#0b0d13;border:1px solid #20273a;border-radius:var(--radius);
      overflow:hidden;box-shadow:0 10px 30px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.04);
      isolation:isolate;user-select:none
    }
    .layer{position:absolute;inset:0}
    .layer iframe{position:absolute;inset:0;width:100%;height:100%;border:0;pointer-events:none}
    #video-shell{pointer-events:none} .controls,.slider-handle{pointer-events:auto}

    /* スライダーハンドル */
    .slider-handle{position:absolute;top:0;bottom:0;width:2px;background:#ffffff66;left:50%;cursor:ew-resize}
    .slider-dot{position:absolute;top:50%;transform:translate(-50%,-50%);left:50%;width:18px;height:18px;border-radius:50%;background:#fff;box-shadow:0 0 0 4px rgba(0,0,0,.35)}

    /* 角の薄いラベル */
    .corner-label{position:absolute;padding:.35em .6em;border-radius:.6em;background:rgba(0,0,0,.35);color:#e7ebf3;font-size:12px;backdrop-filter:blur(2px)}
    .label-left{top:10px;left:10px}
    .label-right{top:10px;right:10px}

    /* イントロ */
    #intro-overlay{display:grid;place-items:center;background:linear-gradient(180deg,#0b0f1a88,#0b0f1a88);pointer-events:auto}
    .intro-mask{position:absolute;inset:0;background:radial-gradient(60% 60% at 50% 40%,#ffffff08,transparent 70%);mix-blend-mode:screen}
    .intro-center{text-align:center;padding:24px 16px;backdrop-filter:blur(2px);display:grid;gap:12px;justify-items:center}
    .intro-title{font-weight:800;letter-spacing:.5px;font-size:clamp(16px,3.2vw,28px);margin-bottom:8px}
    .intro-sub{color:var(--muted);font-size:13px}
    .intro-progress{width:min(520px,80vw)}
    .intro-progress-bar{position:relative;height:10px;border-radius:999px;background:#1f2a44;overflow:hidden}
    .intro-progress-bar::before{content:"";position:absolute;inset:0;width:var(--p,0%);background:linear-gradient(90deg,#ff6a6a,#e53935)}
    #intro-progress-label{position:absolute;right:8px;top:50%;transform:translateY(-50%);font-size:11px;color:#fff;text-shadow:0 1px 2px rgba(0,0,0,.4)}
    .btn-primary{background:linear-gradient(180deg,#2a6cff,#164cff);color:#fff;border:1px solid #335fff;padding:10px 14px;border-radius:12px;font-weight:700;cursor:pointer}
    .btn-primary[disabled]{opacity:.6;cursor:not-allowed}

    /* コントロール */
    .panel{background:linear-gradient(180deg,#161b27,#121620);border:1px solid #20273a;border-radius:var(--radius);padding:14px;display:grid;gap:12px;box-shadow:0 10px 30px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.04)}
    .row{display:grid;gap:8px;align-items:center}
    .buttons{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    button{background:linear-gradient(180deg,#1a2233,#111725);color:var(--fg);border:1px solid #26324a;padding:10px 12px;border-radius:12px;font-weight:600;cursor:pointer;transition:transform .02s ease,filter .15s ease,background .2s ease}
    button:hover{filter:brightness(1.08)} button:active{transform:scale(.98)}
    button[aria-pressed="true"]{outline:2px solid var(--accent)}
    .seg-btn{border-radius:999px;padding:8px 14px}
    .time{font-variant-numeric:tabular-nums}

    /* YouTube風シーク：薄白=全体 / 濃白=バッファ / 赤=再生 */
    #seek{height:28px;-webkit-appearance:none;background:transparent;border-radius:999px;padding:10px 0;
      background-image:
        linear-gradient(rgba(255,255,255,.25), rgba(255,255,255,.25)),
        linear-gradient(rgba(255,255,255,.60), rgba(255,255,255,.60)),
        linear-gradient(#e53935,#e53935);
      background-repeat:no-repeat;
      background-size:100% 6px, var(--buf,0%) 6px, var(--p,0%) 6px;
      background-position:left center,left center,left center;
    }
    #seek::-webkit-slider-runnable-track{height:6px;background:transparent;border-radius:999px}
    #seek::-moz-range-track{height:6px;background:transparent;border-radius:999px}
    #seek::-ms-track{height:6px;background:transparent;border-radius:999px;border-color:transparent;color:transparent}
    #seek::-webkit-slider-thumb{-webkit-appearance:none;width:14px;height:14px;border-radius:50%;background:#e53935;border:0;box-shadow:0 0 0 6px rgba(229,57,53,.25);transition:transform .12s ease,box-shadow .12s ease}
    #seek::-moz-range-thumb{width:14px;height:14px;border-radius:50%;background:#e53935;border:0;box-shadow:0 0 0 6px rgba(229,57,53,.25);transition:transform .12s ease,box-shadow .12s ease}
    #seek:hover::-webkit-slider-thumb,#seek:active::-webkit-slider-thumb{transform:scale(1.15);box-shadow:0 0 0 8px rgba(229,57,53,.2)}
    #seek:hover::-moz-range-thumb,#seek:active::-moz-range-thumb{transform:scale(1.15);box-shadow:0 0 0 8px rgba(229,57,53,.2)}

    .transport-buttons{display:flex;justify-content:center;align-items:center;gap:10px;flex-wrap:wrap}
    .transport-buttons .primary{font-weight:800}

    .date-buttons{display:flex;gap:8px;flex-wrap:wrap}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="header">
      <div class="title">陸前高田（震災直後と現在）３Ｄ動画 比較</div>
    </div>

    <div class="video-shell" id="video-shell" aria-label="比較ビュー">
      <div class="layer" id="layer-before">
        <div id="yt-before"></div>
        <div class="corner-label label-left">被災直後</div>
      </div>
      <div class="layer" id="layer-after">
        <div id="yt-after"></div>
        <div class="corner-label label-right">現在</div>
      </div>

      <div class="slider-handle" id="slider-handle" hidden><div class="slider-dot"></div></div>

      <div class="layer" id="intro-overlay" role="dialog" aria-modal="true">
        <div class="intro-mask"></div>
        <div class="intro-center">
          <div class="intro-title">被災直後と現在を比較しよう</div>
          <div class="intro-sub" id="intro-sub">同期準備中… バッファリング完了後にデモを表示</div>
          <div class="intro-progress"><div class="intro-progress-bar" id="intro-progress-bar"><span id="intro-progress-label">0%</span></div></div>
          <button id="intro-start-btn" class="btn-primary" disabled>再生開始</button>
          <label class="intro-toggle"><input type="checkbox" id="intro-autostart" checked> 準備完了で自動再生</label>
        </div>
      </div>
    </div>

    <div class="panel controls">
      <div class="row">
        <div class="buttons" id="mode-buttons" role="group" aria-label="表示モード">
          <button id="btn-mode-slider" class="btn seg-btn" aria-pressed="true">スライダー比較</button>
          <button id="btn-mode-fade"   class="btn seg-btn" aria-pressed="false">フェード比較</button>
        </div>
      </div>

      <div class="row">
        <div class="date-buttons" role="group" aria-label="単体表示">
          <button class="btn seg-btn" id="btn-single-old">直後のみ</button>
          <button class="btn seg-btn" id="btn-single-now">現在のみ</button>
          <button class="btn seg-btn" id="btn-back-compare">比較に戻る</button>
        </div>
      </div>

      <div class="row inline" id="fade-controls" aria-live="polite" style="display:none">
        <label for="fade-range">フェード量</label>
        <input type="range" id="fade-range" min="0" max="100" value="50" step="1" />
        <span id="fade-pct" class="time">50%</span>
      </div>

      <div class="row" id="transport">
        <div class="transport-buttons">
          <button id="rewind-5">⟲ -5秒</button>
          <button id="play-pause" class="primary" aria-pressed="false">▶ 再生</button>
          <button id="forward-5">+5秒 ⟳</button>
          <span class="time" id="time-readout">00:00 / 00:00</span>
        </div>
        <input type="range" id="seek" min="0" max="0" value="0" step="0.01" aria-label="シークバー" />
      </div>
    </div>

    <p class="note">動画提供:
      <a href="https://youtu.be/twUhcvIGlpY" target="_blank" rel="noreferrer noopener">陸前高田（震災直後）</a> /
      <a href="https://youtu.be/FON4lib3hgQ" target="_blank" rel="noreferrer noopener">陸前高田（現在）</a>（YouTube）
    </p>
  </div>

  <script src="https://www.youtube.com/iframe_api"></script>
  <script>
    // ==== 設定：2本固定 ====
    const VIDEO_OLD = { id: 'twUhcvIGlpY', label: '直後' };
    const VIDEO_NOW = { id: 'FON4lib3hgQ', label: '現在' };

    // ==== 状態 ====
    let playerBefore=null, playerAfter=null, duration=0;
    let isReadyA=false, isReadyB=false, ticking=null, isPlaying=false;
    let introRunning=true, autoplayBlocked=false, started=false, startScheduled=false;
    let bufferingStartAt=null;

    const SYNC_TOLERANCE = 0.18, TICK_MS = 120;
    const MIN_BUFFER_FRAC = 0.06, MIN_BUFFER_SEC = 3;
    const AUTOPLAY_WATCH_MS = 1200;

    // ==== 要素 ====
    const el=id=>document.getElementById(id);
    const layerBefore=el('layer-before'), layerAfter=el('layer-after'), shell=el('video-shell');
    const sliderHandle=el('slider-handle'), playPause=el('play-pause');
    const seek=el('seek'), timeReadout=el('time-readout');
    const fadeRange=el('fade-range'), fadePct=el('fade-pct');
    const introOverlay=el('intro-overlay'), introBtn=el('intro-start-btn'), introSub=el('intro-sub');
    const introProgBar=el('intro-progress-bar'), introProgLabel=el('intro-progress-label'), introAuto=el('intro-autostart');
    const btnModeSlider=el('btn-mode-slider'), btnModeFade=el('btn-mode-fade');
    const btnSingleOld=el('btn-single-old'), btnSingleNow=el('btn-single-now'), btnBackCompare=el('btn-back-compare');

    // ==== ヘルパ ====
    let currentMode='slider'; // 'slider' | 'fade' | 'single-old' | 'single-now'
    function setActive(btn,on){btn.setAttribute('aria-pressed',on?'true':'false')}
    function formatTime(sec){const s=Math.max(0,Math.floor(sec||0));const m=Math.floor(s/60),r=s%60;return `${String(m).padStart(2,'0')}:${String(r).padStart(2,'0')}`}

    function applySplit(p){p=Math.max(0,Math.min(100,p));layerAfter.style.clipPath=`inset(0 0 0 ${p}%)`;sliderHandle.style.left=p+'%'}
    function updateBufferUI(current){
      if(!Number.isFinite(duration)||duration<=0)return;
      const fA=playerBefore?.getVideoLoadedFraction?.()||0, fB=playerAfter?.getVideoLoadedFraction?.()||0;
      const frac=Math.max(0,Math.min(1,Math.min(fA,fB)));
      const played=Math.max(0,Math.min(1,(current||0)/duration));
      seek.style.setProperty('--buf',(frac*100)+'%'); seek.style.setProperty('--p',(played*100)+'%');
    }
    function updateSeekUI(t){
      if(!Number.isFinite(duration)||duration<=0)return;
      const c=Math.min(duration,Math.max(0,t)); seek.max=duration.toFixed(2); seek.value=c.toFixed(2);
      timeReadout.textContent=`${formatTime(c)} / ${formatTime(duration)} (−${formatTime(Math.max(0,duration-c))})`;
      updateBufferUI(c);
    }

    function setMode(mode){
      currentMode=mode;
      setActive(btnModeSlider,mode==='slider'); setActive(btnModeFade,mode==='fade');
      const fadeRow=document.getElementById('fade-controls'); if(fadeRow) fadeRow.style.display=(mode==='fade')?'':'none';

      // 一旦リセット
      layerBefore.style.display=''; layerAfter.style.display='';
      layerAfter.style.opacity=1; layerAfter.style.clipPath='inset(0 0 0 50%)';

      if(mode==='fade'){
        layerAfter.style.clipPath=''; layerAfter.style.width='100%';
        layerAfter.style.opacity=(fadeRange.valueAsNumber/100).toFixed(2);
        sliderHandle.hidden=true; fadeRange.disabled=false;
      }else if(mode==='slider'){
        fadeRange.disabled=true; sliderHandle.hidden=false;
        applySplit(parseFloat(sliderHandle.style.left)||50);
      }else if(mode==='single-old'){
        layerBefore.style.display=''; layerAfter.style.display='none';
        sliderHandle.hidden=true; fadeRange.disabled=true;
      }else if(mode==='single-now'){
        layerBefore.style.display='none'; layerAfter.style.display='';
        layerAfter.style.clipPath='inset(0 0 0 0)'; layerAfter.style.opacity=1;
        sliderHandle.hidden=true; fadeRange.disabled=true;
      }
    }

    // モードボタン
    btnModeSlider.addEventListener('click',()=> setMode('slider'));
    btnModeFade  .addEventListener('click',()=> setMode('fade'));

    // 単体表示
    btnSingleOld.addEventListener('click', ()=> setMode('single-old'));
    btnSingleNow.addEventListener('click', ()=> setMode('single-now'));
    btnBackCompare.addEventListener('click', ()=> setMode('slider'));

    // フェード量
    fadeRange.addEventListener('input',()=>{const v=fadeRange.valueAsNumber;fadePct.textContent=v+'%';if(currentMode==='fade')layerAfter.style.opacity=(v/100).toFixed(2)})

    // スライダー操作
    let dragging=false;
    const onDown=()=>{dragging=true}, onUp=()=>{dragging=false}, onMove=e=>{
      if(!dragging||currentMode!=='slider')return;
      const rect=shell.getBoundingClientRect(), x=(e.touches?e.touches[0].clientX:e.clientX)-rect.left;
      applySplit(Math.max(0,Math.min(100,(x/rect.width)*100)));
    };
    sliderHandle.addEventListener('mousedown',onDown); window.addEventListener('mouseup',onUp); window.addEventListener('mousemove',onMove);
    sliderHandle.addEventListener('touchstart',onDown,{passive:true}); window.addEventListener('touchend',onUp); window.addEventListener('touchmove',onMove,{passive:false});

    // 再生制御
    playPause.addEventListener('click',()=>{
      if(!isReadyA||!isReadyB||introRunning)return;
      if(isPlaying){playerBefore.pauseVideo();playerAfter.pauseVideo();isPlaying=false;playPause.textContent='▶ 再生';playPause.setAttribute('aria-pressed','false')}
      else{playerBefore.playVideo();playerAfter.playVideo();isPlaying=true;playPause.textContent='⏸ 一時停止';playPause.setAttribute('aria-pressed','true')}
    });
    el('rewind-5').addEventListener('click',()=>nudge(-5)); el('forward-5').addEventListener('click',()=>nudge(+5));
    function nudge(d){if(!isReadyA||!isReadyB)return;const t=Math.max(0,Math.min(duration,playerBefore.getCurrentTime()+d));seekToBoth(t,true)}
    seek.addEventListener('input',()=>updateSeekUI(parseFloat(seek.value))); seek.addEventListener('change',()=>seekToBoth(parseFloat(seek.value),true));

    // 同期・シーク
    function seekToBoth(t,ok){playerBefore.seekTo(t,ok);playerAfter.seekTo(t,ok);updateSeekUI(t)}
    function tick(){
      if(!isReadyA||!isReadyB)return;
      const ta=playerBefore.getCurrentTime(), tb=playerAfter.getCurrentTime();
      if(Math.abs(ta-tb)>SYNC_TOLERANCE) playerAfter.seekTo(ta,true);
      updateSeekUI(ta);
    }
    function startTicking(){ if(!ticking) ticking=setInterval(tick,TICK_MS) }
    function stopTicking(){ if(ticking){clearInterval(ticking);ticking=null} }

    // ===== イントロ・スライダーデモ（4秒：25%↔75%） =====
    let introRAF=null;
    function startSliderDemo(){
      setMode('slider');
      sliderHandle.hidden=false;
      let dir = 1;
      let split = 25;
      const min = 25, max = 75;
      const speed = 0.045; // ゆっくり
      const t0 = performance.now();

      function frame(ts){
        if(!introRunning) return;
        const elapsed = ts - t0;
        if(elapsed > 4000){ return; } // 4秒で終了
        split += dir * speed * 16;
        if(split >= max){ split = max; dir = -1; }
        if(split <= min){ split = min; dir = 1; }
        applySplit(split);
        introRAF = requestAnimationFrame(frame);
      }
      introRAF = requestAnimationFrame(frame);
    }
    function stopIntroAnimation(){
      introRunning=false; if(introRAF) cancelAnimationFrame(introRAF);
      // スライダーを中央へ
      const from=parseFloat((sliderHandle.style.left||'').replace('%','')); const f=isNaN(from)?50:from; const to=50, dur=300, t0=performance.now();
      const ease=t=>1-Math.pow(1-t,3);
      function step(ts){const p=Math.min(1,(ts-t0)/dur); applySplit(f+(to-f)*ease(p)); if(p<1) requestAnimationFrame(step)}
      requestAnimationFrame(step);
      introOverlay.setAttribute('inert',''); introOverlay.style.display='none'; playPause?.focus?.();
    }

    // バッファ判定
    function bufferedEnough(p){
      const dur=p.getDuration()||0, frac=(p.getVideoLoadedFraction?p.getVideoLoadedFraction():0)||0;
      const have=Math.max(frac*dur, p.getCurrentTime?p.getCurrentTime():0), need=Math.max(MIN_BUFFER_FRAC*dur, MIN_BUFFER_SEC);
      return have>=need;
    }
    function setIntroProgress(percent){
      const p = Math.max(0, Math.min(100, percent));
      introProgBar.style.setProperty('--p', p+'%');
      introProgLabel.textContent = p.toFixed(0)+'%';
    }

    // 起動時バッファ監視
    function startBufferWatch(){
      let tries = 0, maxTries = 3;
      const timer = setInterval(()=>{
        const tNow=playerBefore?.getCurrentTime?.()||0; updateBufferUI(tNow);
        const ready=bufferedEnough(playerBefore)&&bufferedEnough(playerAfter);
        const elapsed=bufferingStartAt?(performance.now()-bufferingStartAt):0;
        setIntroProgress(Math.min(100, (elapsed/1200)*100));

        if(ready){
          introSub.textContent='準備完了 — デモ後に再生します';
          introBtn.disabled=false;
          if(!started && !startScheduled && !autoplayBlocked){
            startScheduled=true;
            startSliderDemo();
            setTimeout(()=>{ if(!started) beginPlaybackFromZero(); }, 4000);
          }
          clearInterval(timer); // 準備完了で監視終了
        }else{
          introSub.textContent='同期準備中… バッファリング中';
          introBtn.disabled=false;
          if(tries < maxTries && elapsed > (800 * (tries+1))){
            tries++;
            try{ playerBefore.playVideo(); playerAfter.playVideo(); }catch{}
          }
        }
      },180);

      // 自動再生規制検知
      setTimeout(()=>{
        const stA=playerBefore.getPlayerState?.(), stB=playerAfter.getPlayerState?.();
        if(stA!==YT.PlayerState.PLAYING && stB!==YT.PlayerState.PLAYING){
          autoplayBlocked=true;
          introBtn.disabled=false;
          introSub.textContent='ブラウザが自動再生を制限 — 「再生開始」を押してください';
        }
      }, AUTOPLAY_WATCH_MS);
    }

    // 再生開始（デモ終了時に呼ぶ）
    introBtn.addEventListener('click',()=>{ if(!introBtn.disabled){ startSliderDemo(); setTimeout(()=>beginPlaybackFromZero(), 4000); }});
    function beginPlaybackFromZero(){
      if(started) return; started=true; autoplayBlocked=false;
      playerBefore.seekTo(0,true); playerAfter.seekTo(0,true);
      playerBefore.playVideo(); playerAfter.playVideo();
      setMode('slider'); startTicking();
      stopIntroAnimation();
    }

    // YouTube API 初期化
    window.onYouTubeIframeAPIReady=function(){
      playerBefore=new YT.Player('yt-before',{
        videoId:VIDEO_OLD.id,
        playerVars:{
          autoplay:0, controls:0, rel:0, modestbranding:1, playsinline:1, fs:0, iv_load_policy:3,
          loop:1, playlist:VIDEO_OLD.id, disablekb:1, cc_load_policy:0
        },
        events:{ onReady:(e)=>onReady('before',e), onStateChange:onStateChange, onError:onError }
      });
      playerAfter=new YT.Player('yt-after',{
        videoId:VIDEO_NOW.id,
        playerVars:{
          autoplay:0, controls:0, rel:0, modestbranding:1, playsinline:1, fs:0, iv_load_policy:3,
          loop:1, playlist:VIDEO_NOW.id, disablekb:1, cc_load_policy:0
        },
        events:{ onReady:(e)=>onReady('after',e), onStateChange:onStateChange, onError:onError }
      });
    };

    function onReady(which,e){
      try{ e.target.mute(); e.target.setPlaybackQuality('auto'); }catch{}
      if(which==='before') isReadyA=true; else isReadyB=true;
      if(isReadyA && isReadyB){
        const dA=playerBefore.getDuration(), dB=playerAfter.getDuration();
        duration=Math.min(dA||0,dB||0); updateSeekUI(0);
        try{ playerBefore.cueVideoById({videoId:VIDEO_OLD.id, startSeconds:0, suggestedQuality:'auto'}); }catch{}
        try{ playerAfter.cueVideoById({videoId:VIDEO_NOW.id, startSeconds:0, suggestedQuality:'auto'}); }catch{}
        bufferingStartAt=performance.now();
        startBufferWatch();
      }
    }

    // 再生/停止/終了イベント（安定化用デバウンス）
    let stChangeLock=false, isUserSeeking=false;
    function onStateChange(ev){
      if(stChangeLock) return;
      stChangeLock=true; setTimeout(()=>{stChangeLock=false}, 120);
      if(!playerBefore||!playerAfter) return;
      const st=ev.data;
      if(st===YT.PlayerState.PAUSED && isPlaying && !introRunning){
        playerBefore.pauseVideo(); playerAfter.pauseVideo();
        isPlaying=false; playPause.textContent='▶ 再生'; playPause.setAttribute('aria-pressed','false');
      }
      if(st===YT.PlayerState.PLAYING && !isPlaying && !introRunning){
        playerBefore.playVideo(); playerAfter.playVideo();
        isPlaying=true; playPause.textContent='⏸ 一時停止'; playPause.setAttribute('aria-pressed','true');
      }
      if(st===YT.PlayerState.ENDED){
        seekToBoth(0,true); playerBefore.playVideo(); playerAfter.playVideo();
        isPlaying=true; playPause.textContent='⏸ 一時停止'; playPause.setAttribute('aria-pressed','true');
      }
    }

    // エラー時軽いリトライ
    function onError(e){
      const p = e?.target;
      try{
        const id = (p===playerBefore)? VIDEO_OLD.id : VIDEO_NOW.id;
        const t = p?.getCurrentTime?.()||0;
        setTimeout(()=>{ p?.loadVideoById?.({videoId:id, startSeconds:t, suggestedQuality:'auto'}) }, 300);
      }catch{}
    }

    window.addEventListener('beforeunload',()=>{ if(ticking){clearInterval(ticking);} });
  </script>
</body>
</html>
